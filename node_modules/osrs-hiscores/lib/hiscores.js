"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const request_1 = __importDefault(require("./request"));
const parse_csv_1 = __importDefault(require("./parser/parse-csv"));
const url_1 = require("./util/url");
const player_name_1 = __importDefault(require("./util/validate/player-name"));
const parse_html_1 = require("./parser/parse-html");
const stats_1 = require("./util/stats");
const error_1 = require("./util/error");
class Hiscores {
    constructor(config) {
        this.config = {};
        this.config = Object.assign(Object.assign({}, this.config), config);
    }
    /**
     * Fetches the stats for the given player and (optional) mode.
     *
     * @param {string} player The player name to lookup
     * @param {Mode} [mode] The game mode to lookup. Defaults to `normal`
     *
     * @returns {Stats} Player stats formatted as json
     *
     * @throws {InvalidPlayerError} If player name is invalid
     * @throws {ServiceUnavailableError} If hiscores are unavailable
     * @throws {NotFoundError} If hiscores did not find player
     * @throws {HttpError} If hiscores request failed unexpectedly
     * @throws {InvalidCsvError} If the csv had unexpected structure
     */
    getStats(player, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            // Validate player name to avoid requests that are guaranteed to 404
            if (!player_name_1.default(player)) {
                throw new error_1.InvalidPlayerError('Player name is invalid');
            }
            const url = url_1.buildStatsUrl(player, mode);
            const csv = yield request_1.default(url, this.config);
            return parse_csv_1.default(csv);
        });
    }
    /**
     * Finds the players display name (formatted name)
     *
     * @param {string} player The player name to lookup
     * @param {Mode} [mode] The game mode to lookup. Defaults to `normal`
     *
     * @returns {DisplayName} The formatted display name if found, else unformatted
     *
     * @throws {InvalidPlayerError} If player name is invalid
     * @throws {ServiceUnavailableError} If hiscores are unavailable
     * @throws {NotFoundError} If hiscores did not find player
     * @throws {HttpError} If hiscores request failed unexpectedly
     * @throws {InvalidHtmlError} If the html had unexpected structure
     */
    getDisplayName(player, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            // Hiscores tables only display the first 2m players in a stat
            // Find a stat the player is ranked in to use as lookup table
            let displayName = player;
            const stats = yield this.getStats(player, mode);
            const rankedSkill = stats_1.getRankedStat(stats.skills);
            if (rankedSkill) {
                const url = url_1.buildSkillPageWithDisplayNameUrl(player, rankedSkill, mode);
                const html = yield request_1.default(url, this.config);
                displayName = parse_html_1.parseDisplayNamePage(html);
            }
            return { format: displayName };
        });
    }
    /**
     * Fetches a hiscores table page as json
     *
     * @param {SkillName} skill The skill name to get table for
     * @param {Mode} [mode] The game mode to lookup. Defaults to `normal`
     * @param {number} [page] The page number to lookup. Defaults to `0`
     *
     * @returns {PlayerSkillRow[]} Skill table page formatted as json
     *
     * @throws {ServiceUnavailableError} If hiscores are unavailable
     * @throws {HttpError} If hiscores request failed unexpectedly
     * @throws {InvalidHtmlError} If the html had unexpected structure
     */
    getSkillPage(skill, mode, page) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = url_1.buildSkillPageUrl(skill, mode);
            if (page) {
                url = url.concat(`&page=${page}`);
            }
            const html = yield request_1.default(url, this.config);
            return parse_html_1.parseSkillPage(html);
        });
    }
    /**
     * Fetches a hiscores activity table page by activity name
     *
     * @param {Activity} activity The activity name to get table for
     * @param {Mode} [mode] The game mode to lookup. Defaults to `normal`
     * @param {number} [page] The page number to lookup. Defaults to `0`
     *
     * @returns {PlayerActivityRow[]} Activity table page formatted as json
     *
     * @throws {ServiceUnavailableError} If hiscores are unavailable
     * @throws {HttpError} If hiscores request failed unexpectedly
     * @throws {InvalidHtmlError} If the html had unexpected structure
     */
    getActivityPage(activity, mode, page) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = url_1.buildActivityPageUrl(activity, mode);
            if (page) {
                url = url.concat(`&page=${page}`);
            }
            const html = yield request_1.default(url, this.config);
            return parse_html_1.parseActivityPage(html, mode === 'hardcore');
        });
    }
    /**
     * Get the mode of an account.
     *
     * To determine the mode we lookup the players stats for all possible modes. Checks are then
     * perfomed based on the stats to see the state of the player.
     *
     * Normal is the base-case. All snowflake modes will have these stats (due to the hiscores being unreliable
     * lately this may not always be the case. Using `>=` instead of `===` to solve the issue).
     *
     * Ironmen are then separed into categories:
     *   - Ironman (same stats as normal, else de-ironed)
     *   - Hardcore (same stats as ironman, else dead)
     *   - Ultimate (same stats as ironman, else de-ulted)
     *
     * @param {string} Player The player name
     *
     * @returns {PlayerMode} The player mode
     *
     * @throws {InvalidPlayerError} If player name is invalid
     * @throws {ServiceUnavailableError} If hiscores are unavailable
     * @throws {NotFoundError} If hiscores did not find player
     * @throws {HttpError} If hiscores request failed unexpectedly
     * @throws {InvalidCsvError} If the csv had unexpected structure
     */
    getMode(player) {
        return __awaiter(this, void 0, void 0, function* () {
            const normal = yield this.getStats(player);
            const [ironman, hardcore, ultimate] = yield Promise.all([
                this.hasStats(player, 'ironman'),
                this.hasStats(player, 'hardcore'),
                this.hasStats(player, 'ultimate'),
            ]);
            // NOTE: checking for 'overall' only might not be sufficient in case of
            // players that are not ranked 'overall', but in other skills
            if (ironman && ironman.skills.overall.experience >= normal.skills.overall.experience) {
                if (hardcore && hardcore.skills.overall.experience >= ironman.skills.overall.experience) {
                    return { mode: 'hardcore' };
                }
                if (ultimate && ultimate.skills.overall.experience >= ironman.skills.overall.experience) {
                    return { mode: 'ultimate' };
                }
                return { mode: 'ironman' };
            }
            return { mode: 'normal' };
        });
    }
    hasStats(player, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const stats = yield this.getStats(player, mode);
                return stats;
            }
            catch (err) {
                // We are expecting 404's when stats are not found. In which case
                // return false instead of stats.
                // use type of instead?
                if (err.status === 404) {
                    return false;
                }
                // Unexpected errors and hiscores being available should still
                // throw as then we want the entire lookup process to be terminated
                throw err;
            }
        });
    }
}
exports.default = Hiscores;
